### Know about the following topics and explore them (Write a note on your understandings) 
Areas for exploration, 
Child process - fork() 
Handing common signals 
Exploring different Kernel crashes 
Time complexity 
Locking mechanism - mutex/spinlock   
###
----------------------------------------------------------------------


----------------------------------------------------------------------
1. Child Process - fork()

	-fork() is a system call in Unix-based operating systems (like Linux) that is used to create a new process by duplicating an existing one. The new process created is called a child process, and the original process is the parent process.

	-Forking: When fork() is called, the operating system creates a new process by copying the address space of the parent process into the child process. This means the child process initially has the same data, variables, and execution state as the parent, but they run independently from one another.

Return Values:
	-Parent Process: Receives the Process ID (PID) of the child process (positive integer).
	-Child Process: Receives 0.

Example: 
	-If fork() is used in a program, both the parent and the child processes continue executing the same code right after the fork(), but they can take different paths based on the return value of fork().

Use Cases:
	-Creating background processes (e.g., daemons).
	-Multiprocessing where each process can run on a separate core.

Potential Issues:
	-Zombie processes: If the parent does not call wait() to collect the exit status of the child, the child can become a "zombie" process, occupying system resources without doing useful work.
----------------------------------------------------------------------


----------------------------------------------------------------------
2. Handling Common Signals

	-In Unix-like systems, signals are used to communicate between processes. A signal is an asynchronous notification sent to a process to notify it of events like exceptions or other conditions that require special handling.

Key Points:
	-Common Signals:
		-SIGINT: Interrupt signal (usually generated by pressing Ctrl+C). It causes a process to terminate.
		-SIGKILL: Forces a process to terminate immediately. Cannot be caught or ignored.
		-SIGTERM: Termination signal, can be caught or ignored by processes.
		-SIGSEGV: Segmentation fault, caused by invalid memory access.
		-SIGCHLD: Sent to a parent process when one of its child processes terminates.

Handling Signals:
	-You can handle signals using the signal() system call. This allows a program to define custom signal handlers to process signals like SIGINT, SIGTERM, or SIGSEGV.

Example: If a program wants to handle SIGINT (Ctrl+C), a signal handler function can be defined to prevent termination or take a specific action.
----------------------------------------------------------------------


----------------------------------------------------------------------
3. Exploring Different Kernel Crashes
	-A kernel crash occurs when the kernel encounters a serious error that it cannot recover from, typically due to a hardware failure, software bug, or resource exhaustion.

Common Causes:
	-Null Pointer Dereference: When the kernel tries to access memory through a pointer that is NULL, leading to a crash.
	-Memory Corruption: A crash can occur due to improper memory handling, such as buffer overflows.
	-Division by Zero: When the kernel attempts to divide a value by zero.
	-Deadlocks: When processes or threads are waiting for each other indefinitely, leading to a system freeze.
	-Device Driver Bugs: Faulty or incompatible device drivers can crash the kernel.

Out of Memory: When the system runs out of memory and the kernel is unable to allocate more, leading to a panic.

Handling Kernel Crashes:
	-Kernel Panic: A kernel crash typically results in a "kernel panic," where the kernel halts the system to prevent further damage.
	-Crash Dump: Many systems generate a crash dump or core dump when a kernel panic occurs. This can be used for post-mortem analysis.

Preventive Measures:
	-Memory Protection: Techniques like Address Space Layout Randomization (ASLR) can help prevent certain types of kernel crashes.
	-Proper Driver Handling: Ensuring device drivers are well-tested can minimize kernel crashes.
----------------------------------------------------------------------


----------------------------------------------------------------------
4.Time Complexity

	-Time complexity is a way to describe the efficiency of an algorithm in terms of the amount of time it takes to run as a function of its input size. It is often expressed using Big O notation (e.g., O(n), O(log n)).

Types of Time Complexities:

	-O(1): Constant time. The algorithm runs in the same time, regardless of the input size. Example: accessing an element in an array.

	-O(n): Linear time. The running time increases linearly with the input size. Example: searching for an element in an unsorted list.

	-O(log n): Logarithmic time. The running time grows logarithmically with input size. Example: binary search in a sorted array.

	-O(n²): Quadratic time. The running time grows quadratically with the input size. Example: bubble sort.

	-O(n!): Factorial time. The running time grows factorially. Example: solving a traveling salesman problem by checking all permutations.
----------------------------------------------------------------------


----------------------------------------------------------------------
5.Locking Mechanisms: Mutex and Spinlock

	-Locking mechanisms are essential in multi-threading environments to prevent race conditions — situations where multiple threads access and modify shared resources simultaneously, leading to unpredictable results.

1. Mutex (Mutual Exclusion Lock)
	-A mutex is a synchronization primitive that ensures that only one thread can access a critical section of code at a time. If a thread locks a mutex, other threads attempting to lock the same mutex will be blocked until it is unlocked.

Blocking: If a thread tries to lock a mutex that is already locked by another thread, it blocks until the mutex becomes available.

Use Case: Best suited for long critical sections where blocking is acceptable.

Key Operations:
	-pthread_mutex_lock(): Locks the mutex (if it’s already locked, the thread is blocked).
	-pthread_mutex_unlock(): Unlocks the mutex, allowing other threads to access the critical section.

2.Spinlock
	-A spinlock is a synchronization primitive used in multi-threading to protect shared resources, similar to a mutex, but with a key difference in behavior.

Key Points:

	-Non-blocking: When a thread tries to acquire a spinlock and it is already locked by another thread, the thread does not block. Instead, it repeatedly checks (or "spins") to see if the lock becomes available.

	-Busy-waiting: This spinning consumes CPU cycles because the thread is constantly checking for the lock rather than yielding control.

	-Short Critical Sections: Spinlocks are more efficient when the critical section is very short and the lock is expected to be available soon. If the lock is held for a longer time, spinning wastes CPU resources, and a mutex would be a better choice.

	-Performance Considerations: For short waits, spinlocks can be faster than mutexes because they avoid the overhead of thread context switching. However, for long waits, they can become inefficient because they keep the CPU busy without doing useful work.
----------------------------------------------------------------------



